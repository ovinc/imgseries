"""Reflectance analysis: average grey level over time in img sequence."""

# Non-standard modules
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from imgbasics.cropping import _cropzone_draw

# Local imports
from .general import Analysis, PandasTsvResults, PandasFormatter
from ..image_parameters import Zones
from ..viewers import AnalysisViewer


# ======================= Plotting / Animation classes =======================


class GreyLevelViewer(AnalysisViewer):

    def _create_figure(self):
        self.fig = plt.figure(figsize=(5, 7))

    def _first_plot(self, data):
        """What to do the first time data arrives on the plot.

        self.updated_artists must be defined here.
        """
        img = data['image']
        num = data['num']
        glevels = data['glevels']

        self.ax = self.fig.add_axes([0.05, 0.33, 0.9, 0.65])
        self.ax_curves = self.fig.add_axes([0.05, 0.09, 0.9, 0.25])

        # image
        self.ax.set_title(f'img #{num}')
        self.imshow = self.analysis.img_series._imshow(img,
                                                       ax=self.ax,
                                                       **self.kwargs)
        self.ax.axis('off')

        # curves
        self.curves = []
        self.pts = []

        for zone_name, glevel in zip(self.analysis.zones.data, glevels):

            full_data = self.analysis.results.data[zone_name]

            curve, = self.ax_curves.plot(full_data, label=zone_name)
            color = curve.get_color()
            pt, = self.ax_curves.plot(num, glevel, 'o', c=color)

            zone = self.analysis.zones.data[zone_name]
            _cropzone_draw(self.ax, zone, c=color)

            self.curves.append(curve)
            self.pts.append(pt)

        self.ax_curves.legend()
        self.ax_curves.grid()

        self.updated_artists = self.pts + [self.imshow]

    def _update_plot(self, data):
        """What to do upon iterations of the plot after the first time."""
        img = data['image']
        num = data['num']
        glevels = data['glevels']

        self.ax.set_title(f'img #{num}')

        self.imshow.set_array(img)
        for pt, glevel in zip(self.pts, glevels):
            pt.set_data((num, glevel))


class GreyLevelFormatter_Pandas(PandasFormatter):

    def _prepare_data_storage(self):
        """Prepare structure(s) that will hold the analyzed data."""
        self.glevel_data = []

    def _store_data(self, data):
        """How to store data generated by analysis on a single image.

        Define in subclasses."""
        self.glevel_data.append(data)

    def _generate_pandas_data(self):
        """How to convert data generated by _store_data() into a pandas table."""
        zone_names = self.analysis.zones.data.keys()  # 'zone 1', 'zone 2', etc.
        data_table = pd.DataFrame(self.glevel_data,
                                  index=self.analysis.nums,
                                  columns=zone_names)
        data_table.index.name = 'num'
        return data_table

    def _regenerate_data(self, num):
        """How to go back to raw dict of data from self.data.

        Useful for plotting / animating results again after analysis, among
        other things.
        """
        data = {'num': num}
        data['image'] = self.analysis.img_series.read(num=num)
        try:
            data['glevels'] = list(self.analysis.results.data.filter(like='zone').loc[num])
        except AttributeError:  # if self.data not defined (analysis not made)
            pass
        return data


class GreyLevelResults_PandasTsv(PandasTsvResults):
    measurement_type = 'glevel'



# =========================== Main ANALYSIS class ============================


class GreyLevel(Analysis):
    """Class to perform analysis of average grey level on image series."""

    measurement_type = 'glevel'

    DefaultViewer = GreyLevelViewer
    DefaultFormatter = GreyLevelFormatter_Pandas
    DefaultResults = GreyLevelResults_PandasTsv

    def __init__(self,
                 img_series,
                 savepath=None,
                 Viewer=None,
                 Formatter=None,
                 Results=None,
                 ):
        """Analysis of avg gray level on selected zone in series of images.

        Parameters
        ----------
        - img_series: image series from the ImgSeries class or subclasses

        - savepath: folder in which to save analysis data & metadata
                    (if not specified, the img_series savepath is used)

        - Viewer: Viewer class/subclasses that is used to display and inspect
                  analysis data (is used by ViewerTools)
                  (if not specified, use default Viewer)

        - Formatter: class/subclass of Formatter to format results spit out
                     by the raw analysis into something storable/saveable
                     by the Results class.
                     (if not specified, use default Formatter)

        - Results: Results class/subclasses that is used to store, save and
                   load analysis data and metadata.
                   (if not specified, use default Results)
        """
        super().__init__(img_series=img_series,
                         savepath=savepath,
                         Viewer=Viewer,
                         Formatter=Formatter,
                         Results=Results,
                         )

        # empty zones object, needs to be filled with zones.define() or
        # zones.load() prior to starting analysis with self.run()
        self.zones = Zones(self)

    def _analyze(self, num, live=False):
        """Basic analysis function, to be threaded or multiprocessed.

        Parameters
        ----------
        - num: file number identifier across the image file series
        - live: if True, analysis results are displayed in real time

        Output
        ------
        - data, handled by self._store_data()
        """
        glevels = []
        img = self.img_series.read(num)
        for cropzone in self.zones.data.values():
            img_crop = self.img_series.image_manager.crop(img, cropzone)
            glevel = np.mean(img_crop)
            glevels.append(glevel)
        return glevels

    def _initialize(self):
        """Check everything OK before starting analysis & initialize params."""
        if self.zones.is_empty:
            msg = "Analysis zones not defined yet. Use self.zones.define(),  "\
                  "or self.zones.load() if zones have been previously saved."
            raise AttributeError(msg)

    def _add_metadata(self):
        """Add useful analysis parameters etc. to the self.metadata dict.

        (later saved in the metadata json file)
        Define in subclasses
        """
        self.results.metadata['zones'] = self.zones.data

    def regenerate(self, filename=None):
        """Save data and metadata into tsv/json files."""

        # Load data
        super().regenerate(filename=filename)

        # regenerate internal zones object
        self.zones.load(filename=filename)
