"""Analysis of image series (base class)"""

# Standard library imports
import os
from concurrent.futures import ProcessPoolExecutor, as_completed
from pathlib import Path

# Nonstandard
from tqdm import tqdm
from filo import AnalysisBase

# local imports
from .formatters import Formatter
from .results import Results
from ..viewers import AnalysisViewer


class Analysis(AnalysisBase):
    """Base class for analysis subclasses (GreyLevel, ContourTracking, etc.)."""

    measurement_type = None  # define in subclasses (e.g. 'glevel', 'ctrack', etc.)

    DefaultViewer = AnalysisViewer     # redefine in subclasses
    DefaultFormatter = Formatter       # redefine in subclasses
    DefaultResults = Results           # redefine in subclasses

    def __init__(
        self,
        img_series,
        savepath=None,
        Viewer=None,
        Formatter=None,
        Results=None,
    ):
        """Initialize Analysis object

        Parameters
        ----------
        img_series : ImgSeries or ImgStack object
            image series on which the analysis will be run

        savepath : str or Path object
            folder in which to save analysis data & metadata
                    (if not specified, the img_series savepath is used)

        Viewer : class
            (subclass of AnalysisViewer)
            Viewer class/subclasses that is used to display and inspect
            analysis data (is used by ViewerTools)

        Formatter: class
            (subclass of Formatter)
            class used to format results spit out by the raw analysis into
            something storable/saveable by the Results class.

        Results : class
            (subclass of Results)
            Results class/subclasses that is used to store, save and load
            analysis data and metadata.
        """
        super().__init__(data_series=img_series)

        Viewer = self.DefaultViewer if Viewer is None else Viewer
        Formatter = self.DefaultFormatter if Formatter is None else Formatter
        Results = self.DefaultResults if Results is None else Results

        self.img_series = img_series
        self.viewer = Viewer(self)
        self.formatter = Formatter(self)

        savepath = Path(savepath) if savepath else img_series.savepath
        self.results = Results(savepath=savepath)

        if self.img_series.is_stack:
            # Below, pre-populate parameters to be saved as metadata.
            # Other metadata will be added to this dict before saving
            # into metadata file
            stack_path = os.path.relpath(self.img_series.path, savepath)
            self.results.metadata['stack'] = stack_path
        else:
            folders = [
                os.path.relpath(f, savepath) for f in self.img_series.files.folders
            ]
            self.results.metadata['path'] = str(savepath.resolve()),
            self.results.metadata['folders'] = folders

    # ============================ Public methods ============================

    def regenerate(self, filename=None):
        """Load saved data, metadata and regenerate objects from them.

        Is used to reset the system in a state similar to the end of the
        analysis that was made before saving the results.

        Parameters
        ----------
        filename : str
            name of the analysis results file (if None, use default)

        Notes
        -----
            More or less equivalent to:
            >>> analysis.results.load(filename=filename)
            >>> image_series.load_transforms()
            (except that transforms are loaded from the metadata file of the
            analysis, not from a file generated by
            image_series.save_transforms())
        """
        # load data from files
        self.results.load(filename=filename)

        # re-apply transforms and corrections (rotation, crop etc.)
        for name, correction in self.img_series.corrections.items():
            correction.reset()
            correction.data = self.results.metadata.get(name, {})

        for name, transform in self.img_series.transforms.items():
            transform.reset()
            transform.data = self.results.metadata.get(name, {})

    # ======================= Methods of AnalysisBase ========================

    def _initialize(self):
        """Check everything OK before starting analysis & initialize params."""
        self._init_analysis()
        self._add_metadata()
        self._add_transforms_to_metadata()
        self.formatter._prepare_data_storage()

    def _store_data(self, data):
        """How to handle results spit out by analysis"""
        self.formatter._store_data(data)

    def analyze(self, num, details=False):
        """Same as _analyze, but with num as input instead of img.

        Can be subclassed if necessary.

        Parameters
        ----------
        num : int
            file number identifier across the image file series

        details : bool
            whether to include more details (e.g. for debugging or live view)

        Returns
        -------
        dict
            data, handled by formatter._store_data()"""
        img = self.img_series.read(num=num)
        data = self._analyze(img=img)
        data['num'] = num
        if details:
            data['image'] = img
        return data

    def _finalize(self):
        """What to do at the end of analysis"""
        self.formatter._to_results()

    # ========================= Other useful methods =========================

    def _add_transforms_to_metadata(self):
        """Add information about image transforms (rotation, crop etc.) to metadata."""
        for name, correction in self.img_series.corrections.items():
            self.results.metadata[name] = correction.data

        for name, transform in self.img_series.transforms.items():
            self.results.metadata[name] = transform.data

    # =================== Methods to define in subclasses ====================

    def _init_analysis(self):
        """Any initialization steps necessary in the analysis in addition
        to metadata saving and formatter init.
        Define in subclasses."""
        pass

    def _add_metadata(self):
        """Add useful analysis parameters etc. to the self.metadata dict.

        (later saved in the metadata json file)
        Define in subclasses."""
        pass

    def _analyze(self, img, details=False):
        """Analysis process on single image. Must return a dict.

        Parameters
        ----------
        img : array-like
            image array to be analyzed (e.g. numpy array).

        details : bool
            whether to include more details (e.g. for debugging or live view)

        Returns
        -------
        dict
            dict of data, handled by formatter._store_data()

        Define in subclasses."""
        pass
