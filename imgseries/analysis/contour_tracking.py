"""Contour tracking on image series."""

# Misc. package imports
from skimage import measure
from numpy import nan as NaN
import numpy as np
import matplotlib.pyplot as plt
import imgbasics

# Local imports
from .analysis_base import Analysis
from .formatters import AnalysisPandasFormatterBase, AnalysisFormatterBase
from .formatters import MultiFormatterBase
from .results import ResultsBase
from ..process import rgb_to_grey
from ..fileio import FileIO
from ..parameters.analysis import Contours, Threshold
from ..parameters.analysis import ContourProperties, ContourCoordinates
from ..viewers import AnalysisViewer


# =================== Contour management and calculations ====================


class Contour:
    """Class that represents contour data and properties"""

    def __init__(self, coordinates=None, properties=None):
        """x, y are the coordinates of the contour

        Either coordinates and properties can be None, because contour data
        can store coortinates, properties, or both.
        """
        self.coordinates = coordinates
        # not None when calculate_properties() called
        self.properties = properties

    def calculate_properties(self):
        """Calculate centroid, perimeter, area and store it in self.properties"""
        ppties = imgbasics.contour_properties(
            x=self.coordinates.x,
            y=self.coordinates.y
        )
        self.properties = ContourProperties(**ppties)

    def reset_properties(self):
        """Remove calculated properties data."""
        self.properties = None

    @classmethod
    def from_opencv(cls, contour_data):
        x, y = imgbasics.contour_coords(contour_data, source='opencv')
        return cls(coordinates=ContourCoordinates(x=x, y=y))

    @classmethod
    def from_scikit(cls, contour_data):
        x, y = imgbasics.contour_coords(contour_data, source='scikit')
        return cls(coordinates=ContourCoordinates(x=x, y=y))


# ============================ Results formatting ============================


# Here we combine two formatters using a multiformatter
# one is for contour properties (centroid, area etc.)
# the other one is for raw contour data (coordinates)


class ContourTrackingPropertiesFormatter(AnalysisPandasFormatterBase):
    """Format contour properties (area, position etc.) results"""

    @property
    def results_dataframe(self):
        """Redefined here because pandas dataframe is not directly in results.data"""
        return self.analysis.results.data['properties']

    def _column_names(self):
        """Prepare structure(s) that will hold the analyzed data."""
        names = 'x', 'y', 'p', 'a'  # measurement names (p, a perimeter, area)
        return [
            f'{name}{k + 1}'
            for k in range(self.analysis.n_contours)
            for name in names
        ]

    def _data_to_results_row(self, data):
        """Generate iterable of data that fits in the defined columns."""
        all_info = []

        for contour in data['contours']:

            if contour is None:    # no contour detected.
                info = (NaN,) * 4
            else:
                ppties = contour.properties
                info = (*ppties.centroid, ppties.area, ppties.perimeter)

            all_info.append(info)

        return sum(all_info, start=())  # "Flatten" list of tuples

    def _results_row_to_data(self, row):
        """Go from row of data to properties data

        (not full data dict, combined with the multiformatter)
        """
        properties_data = []

        for k in range(self.analysis.n_contours):

            lim1 = 'x' + str(k + 1)  # contour positions and perimeters
            lim2 = 'a' + str(k + 1)
            xc, yc, perimeter, area = row.loc[lim1:lim2]

            ppties = ContourProperties(
                centroid=(xc, yc),
                perimeter=perimeter,
                area=area,
            )

            properties_data.append(ppties)

        return properties_data

    def _to_metadata(self):
        """Get analysis metadata excluding paths and transforms"""
        return {'contours': self.analysis.contours.data}


class ContourTrackingCoordinatesFormatter(AnalysisFormatterBase):
    """Format full contour coordinates (x, y data) results"""

    def _prepare_data_storage(self):
        """Prepare structure(s) that will hold the analyzed data"""
        if not self.analysis.save_contours:
            return

        self.contour_coord_data = {
            f'contour {k + 1}': {}
            for k in range(self.analysis.n_contours)
        }

    def _store_data(self, data):
        """How to store data generated by analysis on a single image.

        Input
        -----
        data : dict
            Dictionary of data, output of Analysis.analyze()
        """
        if not self.analysis.save_contours:
            return

        num = data['num']

        for k, contour in enumerate(data['contours']):

            if contour is not None:
                coords = {
                    'x': list(contour.coordinates.x),
                    'y': list(contour.coordinates.y),
                }
            else:
                coords = None

            # The str is because JSON converts to str, and so this makes
            # live data compatible with reloaded data from JSON
            self.contour_coord_data[f'contour {k + 1}'][str(num)] = coords

    def _to_results_data(self):
        """Return partial data that will be combined with the multiformatter"""
        if not self.analysis.save_contours:
            return
        return self.contour_coord_data

    def _regenerate_analysis_data(self, num):
        """How to go back to raw data (as spit out by the analysis methods
        during analysis) from data saved in results or files."""
        try:
            coord_data = self.analysis.results.data['coordinates']
        except KeyError:
            return  # No coordinates data in results -> return None

        try:
            coord_data['contour 1'][str(num)]
        except KeyError:  # this particular num not analyzed -> return None
            return

        data = []

        for k in range(self.analysis.n_contours):

            contour_coords = coord_data[f'contour {k + 1}'][str(num)]

            if contour_coords is None:
                coords = None
            else:
                coords = ContourCoordinates(**contour_coords)

            data.append(coords)

        return data


class ContourTrackingFormatter(MultiFormatterBase):
    """Combine property formatter and coordinates formatter"""

    Formatters = [
        ContourTrackingPropertiesFormatter,
        ContourTrackingCoordinatesFormatter,
    ]

    def _combine_results_data(self, individual_data):
        """How to combine individual data obtained from _to_results_data()

        individual_data is a list of data produced by each
        _to_results_data() methods of individual formatters

        Returns data that will be stored in results.data
        """
        contour_ppties, contour_coords = individual_data

        coords_dict = {'coordinates': contour_coords}
        ppties_dict = {'properties': contour_ppties}

        if self.analysis.save_contours:
            return {**ppties_dict, **coords_dict}
        else:
            return ppties_dict

    def _combine_regenerated_data(self, individual_regenerated_data):
        """How to combine individual data obtained from _to_results_data()

        [OPTIONAL]

        individual_data is a list of data produced by each
        _regenerate_analysis_data() methods of individual formatters

        Returns regenrated data that will sent to viewers etc.
        """
        contour_ppties, contour_coords = individual_regenerated_data

        # No data at all (e.g. required num not analyzed)
        if not (contour_ppties or contour_coords):
            # It's important to return a dict here, because of the
            # way filo.FormatterBase combined data with
            # _regenerate_data_from_results()
            return {}

        if not contour_coords:
            contour_coords = [None] * self.analysis.n_contours

        if not contour_ppties:
            contour_coords = [None] * self.analysis.n_contours

        contours = [
            Contour(coordinates=coords, properties=ppties)
            for coords, ppties in zip(contour_coords, contour_ppties)
        ]

        return {'contours': contours}


# ============================= Results classes ==============================


class ContourTrackingResults(ResultsBase):

    # define in subclass (e.g. 'Img_GreyLevel')
    # Note that the program will add extensions depending on context
    # (data or metadata).
    default_filename = 'Img_ContourTracking'

    # Define type of data (e.g. data / metadata and corresponding extensions)
    # Possible to change in subclasses.
    # Possible to put
    extensions = {
        'data': ('.tsv', '.json'),
        'metadata': ('.json',),
    }

    # What to add to the default filename or specified filename
    # needs to be same length as extensions above.
    # useful if two extensions are the same, to distinguish filenames
    filename_adds = {
        'data': ('', '_Coords'),
        'metadata': ('',),
    }

    # Corresponding loading and saving methods, possibility to put several
    # in order to save data to various files or different formats.
    # Must be same length as extensions above.
    load_methods = {
        'data': ('_load_data_properties', '_load_data_coordinates'),
        'metadata': ('_load_metadata',),
    }

    # idem for save methods
    save_methods = {
        'data': ('_save_data_properties', '_save_data_coordinates'),
        'metadata': ('_save_metadata',),
    }

    # Loading data -----------------------------------------------------------

    def _load_data_properties(self, filepath):
        return FileIO.from_tsv(filepath=filepath)

    def _load_data_coordinates(self, filepath):
        try:
            data = FileIO.from_json(filepath=filepath)
        except FileNotFoundError:  # no coordinates saved
            data = None
        return data

    def loaded_data_to_data(self, loaded_data):
        """How to go from the results of load_data into self.data

        Possibility to subclass, by default assumes just one
        data returned that goes directly into self.data
        """
        data_props, data_coords = loaded_data

        coords_dict = {'coordinates': data_coords} if data_coords else {}
        ppties_dict = {'properties': data_props}

        return {**ppties_dict, **coords_dict}

    # Saving data ------------------------------------------------------------

    def _save_data_properties(self, data, filepath):
        FileIO.to_tsv(data=data['properties'], filepath=filepath)

    def _save_data_coordinates(self, data, filepath):
        try:
            coord_data = data['coordinates']
        except KeyError:
            return
        FileIO.to_json(data=coord_data, filepath=filepath)

    # Loading and saving metadata --------------------------------------------

    def _load_metadata(self, filepath):
        return FileIO.from_json(filepath=filepath)

    def _save_metadata(self, metadata, filepath):
        return FileIO.to_json_with_gitinfo(data=metadata, filepath=filepath)


# ======================= Plotting / Animation classes =======================


class ContourTrackingViewer(AnalysisViewer):

    def _plot_contours_and_centroids(self, data):

        self.centroid_pts = []
        self.contour_lines = []

        for _ in range(self.analysis.n_contours):
            centroid_pt, = self.ax_img.plot([], [], '+')
            contour_line, = self.ax_img.plot([], [], '-', c=centroid_pt.get_color())
            self.centroid_pts.append(centroid_pt)
            self.contour_lines.append(contour_line)

        self._update_contours_and_centroids(data)

    def _hide_all(self):
        for pt, line in zip(self.centroid_pts, self.contour_lines):
            pt.set_visible(False)
            line.set_visible(False)

    def _update_contours_and_centroids(self, data):

        try:
            contours = data['contours']
        except KeyError:  # no contour data in incoming data
            self._hide_all()
            return

        for contour, pt, line in zip(
            contours,
            self.centroid_pts,
            self.contour_lines,
        ):
            if contour is None:
                continue

            if contour.properties is None:
                pt.set_visible(False)
            else:
                pt.set_visible(True)
                xc, yc = contour.properties.centroid
                pt.set_data((xc,), (yc,))

            if contour.coordinates is None:
                line.set_visible(False)
            else:
                line.set_visible(True)
                line.set_data(contour.coordinates.x, contour.coordinates.y)

    # ---------------- Methods subclassed from AnalysisViewer ----------------

    def _create_figure(self):
        self.fig, self.ax_img = plt.subplots()
        self.ax_img.axis('off')
        self.axs = self.ax_img,

    def _first_plot(self, data):
        """What to do the first time data arrives on the plot."""
        self._create_image(data)
        self.fig.tight_layout()
        self._plot_contours_and_centroids(data)
        self.updated_artists = self.centroid_pts + self.contour_lines + [self.imshow]

    def _update_plot(self, data):
        """What to do upon iterations of the plot after the first time."""
        self._update_image(data)
        self._update_contours_and_centroids(data)


# =========================== Main ANALYSIS class ============================


class ContourTracking(Analysis):
    """Class to track contours on image series.

    Class attributes
    ----------------
    Viewer : class
        (subclass of AnalysisViewer)
        Viewer class/subclasses that is used to display and inspect
        analysis data (is used by ViewerTools)

    Formatter: class
        (subclass of Formatter)
        class used to format results spit out by the raw analysis into
        something storable/saveable by the Results class.

    Results : class
        (subclass of Results)
        Results class/subclasses that is used to store, save and load
        analysis data and metadata.
    """
    Viewer = ContourTrackingViewer
    Formatter = ContourTrackingFormatter
    Results = ContourTrackingResults

    # If results are independent (results from one num do not depend from
    # analysis on other nums), one do not need to re-do the analysis when
    # asking for the same num twice, and parallel computing is possible
    independent_results = False

    def __init__(
        self,
        img_series,
        savepath=None,
        save_contours=True,
        tolerance_displacement=None,
        tolerance_area=None,
    ):
        """Analysis of iso-grey-level contours and their evolution in series.

        Parameters
        ----------
        img_series : ImgSeries or ImgStack object
            image series on which the analysis will be run

        savepath : str or Path object
            folder in which to save analysis data & metadata
                    (if not specified, the img_series savepath is used)

        save_contours : bool
            if True (default), all coordinates of contour lines are saved in
            addition to contour positions, centroids and areas.

        save_contours : bool
            if True (default), all coordinates of contour lines are saved in
            addition to contour positions, centroids and areas.

        tolerance_displacement : float
            if None (default), no restriction on displacements
            if value = d > 0, do not consider displacements more than d pixels

        tolerance_area : float
            if None (default), no restriction on area variations of contours
            if value = x > 0, do not consider relative variation in area of
            more than x.
        """
        super().__init__(img_series=img_series, savepath=savepath)

        self.save_contours = save_contours

        # empty contour param object, needs to be filled with contours.define()
        # or contours.load() prior to starting analysis with self.run()
        self.contours = Contours(self)
        self.threshold = Threshold(self)

        # Tolerance in displacement and areas to match contours
        self.tolerance_displacement = tolerance_displacement
        self.tolerance_area = tolerance_area

    @property
    def n_contours(self):
        return len(self.contours.properties)

    # ======================= Contour analysis methods =======================

    def _find_contours(self, img, level):
        """Define how contours are found on an image."""
        if img.ndim == 2:
            image = img
        else:
            image = rgb_to_grey(img)

        raw_contours = measure.find_contours(image, level)
        contours = [Contour.from_scikit(c) for c in raw_contours]

        return contours

    def _closest_contour_to_click(self, contours, click_position):
        """Define closest contour to position (x, y) for click selection"""
        raw_contours = [
            (contour.coordinates.x, contour.coordinates.y)
            for contour in contours
        ]
        x, y = imgbasics.closest_contour(raw_contours, click_position, edge=True)
        return Contour(coordinates=ContourCoordinates(x=x, y=y))

    def _find_tolerable_contours(self, contours, contour_properties):
        """Find all contours that match tolerance criteria for matching given contour"""

        ok_contours = []

        for contour in contours:

            if self.tolerance_displacement is not None:
                x1, y1 = contour_properties.centroid
                x2, y2 = contour.properties.centroid
                d = np.hypot(x2 - x1, y2 - y1)
                if d > self.tolerance_displacement:
                    continue

            if self.tolerance_area is not None:
                a = abs(contour.properties.area)
                a0 = abs(contour_properties.area)
                x = abs((a - a0)) / a0
                if x > self.tolerance_area:
                    continue

            ok_contours.append(contour)

        return ok_contours

    def _match(self, contours, contour_properties):
        """Find closest contour matching reference contour properties

        tolerance_displacement: max displacement in px
        tolerance_area: max relative change in area
        """
        for contour in contours:
            if contour.properties is None:
                contour.calculate_properties()

        tolerable_contours = self._find_tolerable_contours(
            contours,
            contour_properties,
        )

        # No contours found --> return None
        if len(tolerable_contours) < 1:
            return

        # Among all tolerated contours, return that which is closest (centroid)
        displacements = []
        for contour in tolerable_contours:
            x1, y1 = contour_properties.centroid
            x2, y2 = contour.properties.centroid
            d = np.hypot(x2 - x1, y2 - y1)
            displacements.append(d)

        imin = displacements.index(min(displacements))
        return tolerable_contours[imin]

    # ------------------- Subclassed methods from Analysis -------------------

    def _init_analysis(self):
        """Check everything OK before starting analysis & initialize params."""

        if self.contours.is_empty:
            msg = (
                "Contours not defined yet. Use self.contours.define(), or "
                "self.contours.load() if contours have been previously saved."
            )
            raise AttributeError(msg)

        self.previous_contour_ppties = self.contours.properties.copy()

    def _analyze(self, img):
        """Find contours at level in file i closest to the reference positions.

        Parameters
        ----------
        img : array_like
            image array to be analyzed (e.g. numpy array).

        Returns
        -------
        list of tuples
            [(x1, y1, p1, a1), (y2, y2, p2, a1), ..., (xn, yn, pn, an)]
            where n is the number of contours followed and
            (x, y), p, a is position, perimeter, area
        """
        data = {'contours': []}
        new_contour_ppties = {}

        contours = self._find_contours(img, self.threshold.value)

        # The loop is on the number of followed contours, basically
        for name, prev_contour_ppties in self.previous_contour_ppties.items():

            # contour can be None if no matching contour found
            # (if matching contour, contour is a Contour object)
            contour = self._match(contours, prev_contour_ppties)
            data['contours'].append(contour)

            # If contour not found, keep same ref. ppties as before
            if contour is None:
                new_contour_ppties[name] = prev_contour_ppties
            # If found, update.
            else:
                new_contour_ppties[name] = contour.properties

        self.previous_contour_ppties = new_contour_ppties

        return data

    # ------------------ Redefinitions of Analysis methods -------------------

    def regenerate(self, filename=None):
        """Load saved data, metadata and regenerate objects from them.

        Is used to reset the system in a state similar to the end of the
        analysis that was made before saving the results.

        Parameters
        ----------
        filename : str
            name of the analysis results file (if None, use default)

        Notes
        -----
            More or less equivalent to:
            >>> analysis.results.load(filename=filename)
            >>> image_series.load_transforms()
            (except that transforms are loaded from the metadata file of the
            analysis, not from a file generated by
            image_series.save_transforms())
        """

        # Load data
        super().regenerate(filename=filename)

        # regenerate internal threshold / contours object
        self.contours.load(filename=filename)

        # at the moment, this is already done by contours.load(), but I'm
        # putting this there to be sure in case contours are modified to not
        # include threshold level information
        self.threshold.load(filename=filename)
