"""Base classes for Formatters for analysis of image series"""

# Standard
import os
from abc import abstractmethod

# Nonstandard
import pandas as pd
from filo import FormatterBase


class Formatter(FormatterBase):
    """Base class for formatting of results spit out by analysis methods"""

    def _get_path_metadata(self):
        """Return dict about image path(s)."""
        savepath = self.analysis.results.savepath
        if self.analysis.img_series.is_stack:
            stack_path = os.path.relpath(
                path=self.analysis.img_series.path,
                start=savepath,
            )
            return {'stack': stack_path}
        else:
            folders = [
                os.path.relpath(path=f, start=savepath)
                for f in self.analysis.img_series.files.folders
            ]
            return {'path': str(savepath.resolve()), 'folders': folders}

    def _get_transform_metadata(self):
        """Metadata about image transforms (rotation, crop etc.) """
        info = {}

        for name, correction in self.analysis.img_series.corrections.items():
            # Because correction data typically cannot be saved to JSON
            info[name] = bool(correction.data)

        for name, transform in self.analysis.img_series.transforms.items():
            info[name] = transform.data

        return info

    @property
    def columns(self):
        return list(self._column_names())

    # ============ Redefinition of FormatterBase abstract methods ============

    def _to_results_metadata(self):
        path_metadata = self._get_path_metadata()
        transform_metadata = self._get_transform_metadata()
        other_metadata = self._get_results_metadata()
        return {**path_metadata, **transform_metadata, **other_metadata}

    def _generate_data_from_results(self, num):
        """How to go back to raw data (as spit out by the analysis methods
        during analysis) from data saved in results or files.

        [OPTIONAL]

        Useful for plotting / animating results again after analysis, among
        other things.
        """
        data = self._recreate_data_from_results(num=num)
        data['num'] = num
        data['image'] = self.analysis.img_series.read(num=num)
        return data

    # ================== FormatterBase methods to subclass ===================

    @abstractmethod
    def _prepare_data_storage(self):
        """Prepare structure(s) that will hold the analyzed data"""
        pass

    @abstractmethod
    def _store_data(self, data):
        """How to store data generated by analysis on a single image.

        Input
        -----
        data is a dictionary, output of Analysis.analyze()
        """
        pass

    @abstractmethod
    def _to_results_data(self):
        """How to pass stored data into a Results class/subclass.

        (is executed at the end of analysis)

        Returns
        ------
        Any
            data in the format that will be stored in results.data
        """
        return {}

    # ================= New methods to define in subclasses ==================

    def _recreate_data_from_results(self, num):
        """Recreate dict of raw data from results, excluding 'num' and 'image'"""
        pass

    def _get_results_metadata(self):
        """Get analysis metadata excluding paths and transforms"""
        pass


class PandasFormatter(Formatter):
    """Base class for formatting results as a pandas DataFrame"""

    # ================== Redefinition of Formatter methods ===================

    def _prepare_data_storage(self):
        """Prepare structure(s) that will hold the analyzed data"""
        self.data = pd.DataFrame(columns=self.columns)
        self.data.index.name = 'num'

    def _to_results_data(self):
        """Add file info (name, time, etc.) to analysis results if possible.

        (img_series.info is defined only if ImgSeries inherits from filo.Series,
        which is not the case if img data is in a stack).
        """
        data = self.data.sort_index()
        if self.analysis.img_series.is_stack:
            return data
        else:
            info = self.analysis.img_series.info
            return pd.concat([info, data], axis=1, join='inner')

    def _store_data(self, data):
        """How to store data generated by analysis on a single image."""
        num = data['num']

        # Doing two times the same analysis (e.g. when using inspect(live=True)
        # Should return the same result, so this case is simply ignored)
        if num in self.data.index:
            return

        self.data.loc[num] = self._format_data(data)

    def _recreate_data_from_results(self, num):
        """Recreate dict of raw data from results, excluding 'num' and 'image'"""
        if self.analysis.results.data is None:  # analysis not run or reset
            return {}

        data = self.analysis.results.data[self.columns]

        try:
            row = data.loc[num]
        except KeyError:    # Analysis not made for the specific num
            return {}

        return self._results_row_to_data(row)

    # ============= FormatterBase/Formatter methods to subclass ==============

    def _get_results_metadata(self):
        """Get analysis metadata excluding paths and transforms"""
        pass

    # ================= New methods to define in subclasses ==================

    @abstractmethod
    def _column_names(self):
        """Columns of the analysis data (iterable)"""
        pass

    @abstractmethod
    def _format_data(self, data):
        """Generate iterable of data that fits in the defined columns.

        Input
        -----
        data is a dictionary, output of Analysis.analyze()

        Returns
        -------
        iterable
            must have a length equal to self._column_names()
        """
        pass

    def _results_row_to_data(self, row):
        """Go from row of data to raw data"""
        pass
