"""Analysis of wetting / drying fronts."""

# Non-standard modules
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Local imports
from .config import _crop
from .general import ImgSeries, Analysis


class Front1D(ImgSeries, Analysis):
    """Class to perform analysis of average grey level on image series."""

    name = 'Images Series (1D Front)'  # used for __repr__

    def __init__(self, paths='.', extension='.png', savepath='.', stack=None):
        """Analysis of avg gray level on selected zone in series of images.

        Parameters
        ----------
        - paths: str, path object, or iterable of str/paths if data is stored
          in multiple folders.

        - extension: extension of image files (e.g. '.png')

        - savepath: path in which to save analysis files.

        If file series is in a stack rather than in a series of images:
        - stack: path to the stack (.tiff) file
          (parameters paths & extension will be ignored)
        """
        ImgSeries.__init__(self,
                           paths=paths,
                           savepath=savepath,
                           extension=extension,
                           stack=stack)

        Analysis.__init__(self, measurement_type='front1d')

        # By default, calculate differences with respect to the first image
        # in the sequence. Can be a list or range of images.
        self.reference_images = 0,

    def _create_reference(self):
        """Average all images taken as reference from self.reference_images."""
        imgs = []
        for num in self.reference_images:
            imgs.append(self.read(num=num))
        img_stack = np.stack(imgs)
        img_ref = img_stack.mean(axis=0)
        return img_ref

    def analyze(self, num, live=False):
        """Basic analysis function, to be threaded or multiprocessed.

        Parameters
        ----------
        - num: file number identifier across the image file series
        - live: if True, analysis results are displayed in real time

        Output
        ------
        - data, handled by self.store_data()
        """
        img_diff = (self.read(num=num) - self.img_ref) / self.img_ref
        front_data = img_diff.mean(axis=1)
        data = {'analysis': front_data}
        if live:
            data['image'] = img_diff
        return data

    def initialize(self):
        """Check everything OK before starting analysis & initialize params."""
        self.img_ref = self._create_reference()

    def add_metadata(self):
        """Add useful analysis parameters etc. to the self.metadata dict.

        (later saved in the metadata json file)
        Define in subclasses
        """
        self.metadata['reference images'] = self.reference_images

    def prepare_data_storage(self):
        """Prepare structure(s) that will hold the analyzed data."""
        pass

    def store_data(self, data):
        """How to store data generated by analysis on a single image.

        Define in subclasses."""
        pass

    def generate_pandas_data(self):
        """How to convert data generated by store_data() into a pandas table."""
        pass

    def initialize_plot(self):
        self.fig, (self.ax_img, self.ax_analysis) = plt.subplots(2, 1)

    def plot(self, data):
        """How to plot data during live views of analysis.

        ATTENTION: has to return moving artists if using blitting"""

        img = data['image']
        front = data['analysis']

        self.ax.set_title(f'img #{num}, grey level {self.level}')

        if not self.plot_init_done:

            self.im = self.ax.imshow(img, cmap='gray')
            self.ax.axis('off')

            self.contour_lines = []
            self.centroid_pts = []

            for contour, analysis in zip(data['contours'], data['analysis']):

                contour_line, = self.ax.plot(*contour, '-r')
                self.contour_lines.append(contour_line)

                centroid_pt, = self.ax.plot(*analysis[:2], '+b')
                self.centroid_pts.append(centroid_pt)

            self.fig.tight_layout()
            self.plot_init_done = True

        else:

            self.im.set_array(img)

            for contour, analysis, line, pt in zip(data['contours'],
                                                   data['analysis'],
                                                   self.contour_lines,
                                                   self.centroid_pts):

                if contour is not None:
                    line.set_data(*contour)
                    pt.set_data(*analysis[:2])
                else:
                    line.set_data(None, None)
                    pt.set_data(None, None)

        return self.contour_lines + self.centroid_pts + [self.im]